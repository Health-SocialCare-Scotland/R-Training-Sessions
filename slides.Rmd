---
title: "R training for beginners  "
subtitle: "22nd August 2019"
author: 'Jade Carruthers, Calum Purdie and Tina Fu <br> Stats Gov Team  <br>'
output:
  ioslides_presentation:
    css: my-theme.css
---

```{r setup, include = FALSE}
# Load packages required
library(knitr)
library(magrittr)
library(kableExtra)

knitr::opts_chunk$set(echo = FALSE)

# Create data frame for table
table_contents <- data.frame(c("==", "!=",
                               "<", "<=",
                               ">", ">="),
                             c("Equal to", "Not equal to", "Less than", "Less than or equal to", "More than", "More than or equal to "))

table_contents2 <- data.frame(c("&", "|",
                               "!"),
                              c("AND","OR","NOT"),
                             c("Both relations must be true", "Either relation can be true", "Logical negation operator. Reverses the outcome of an expression"))


```


## What will you learn today?

- RStudio interface

- Reading data into RStudio from multiple sources

- Installing and using R packages

- Manipulating data using R code

- Exploring data using crosstabs and frequencies

- Becoming familiar with the widely used dplyr package



## What is R?

- R is a language and environment for statistical computing and graphics

- Widely used across a variety of sectors for data analysis and statistical inference

- R is open source and free to use, and available for all major operating systems


## R or RStudio?

RStudio is a free and open-source integrated development environment for R, a programming language for statistical computing and graphics. You cannot run RStudio without R.

- RStudio is more flexible and powerful, and provides direct access to R code
- Both are good for viewing data, neither is good for manually editing data
- Use RStudio for any project that requires direct interaction with code and/or manipulation of complex data

## Functions and data embedded in R

```{r,  eval=FALSE,echo=TRUE}
summary(cars)
```

```{r}
summary(cars)
```

## Easy to plot charts 

```{r,  eval=FALSE,echo=TRUE}
plot(cars)
```

```{r}
plot(cars)
```


## R packages 

Packages allow you to use R much more efficiently. Rather than simply relying on some basic R techniques, they build on some widely used R methods and often make complex tasks very straight forward. R packages cover a wide range of needs. 

Try typing:


```{r,  eval=FALSE,echo=TRUE}
packageDescription("stats")
help(package = "stats")
```

## How to import and export data 

- CSV
- Excel 
- SPSS
- SMRA


## CSV


A simple command will read in a CSV file

```{r,  eval=FALSE,echo=TRUE}
dataset <- read.csv("filepath and name")
```

- An alternative is clicking on the Import Dataset from your global environment section. 


Let's try an example! 

## EXAMPLE

Read in the Borders data from 


```{r,  eval=FALSE,echo=TRUE}
Borders <- read.csv("H:/R Training Data/Borders.csv")
```


## SPSS


A simple command will read in a SPSS file

```{r,  eval=FALSE,echo=TRUE}
install.packages("haven")
library(haven)
Borders <- read_sav("filepath")
View(Borders)

```

- An alternative is clicking on the Import Dataset from your global environment section similar to CSV. 


Let's try an example! 

## EXAMPLE

Read in the Borders excel data from 


- H:/R Training Data 


*keep an eye out for a package being installed! 



## SMRA (for information only)

Reading data from SMRA is slightly more tricky.


```{r,  eval=FALSE,echo=TRUE}
install.packages("odbc") # One time install
library(odbc)
# Set up a connection
smra_connection <- dbConnect(drv = odbc(), dsn = "SMRA",
  uid = .rs.askForPassword("SMRA Username:"),
  pwd = .rs.askForPassword("SMRA Password:")
)

# Do the extract using SQL
smr01 <- dbGetQuery(smra_connection,
  paste("select DISCHARGE_DATE, LOCATION, MAIN_OPERATION",
    "from SMR01_PI",
    "where ROWNUM <= 100")
)
```
Instructions on using R to connect to SMRA can be found on the [ISD WEBSITE](https://www.isdscotland.org/About-ISD/Methodologies/_docs/Using-R-with-SMRA-V1-1.pdf)



## Data Exploration - Data Frame 

Let's do some data exploration :

As a first step in this process, it is important to know the size of the dataframe. 


```{r,  eval=FALSE,echo=TRUE}
dim(df)
```
We can check the number of rows and columns for the Borders dataframe 


```{r,  eval=FALSE,echo=TRUE}
dim(Borders)
```

## Data Exploration

You can easily determine summary statistics of a specific column in R. For example, we can calculate the mean by using the `mean(df$column)` command. The $ operator allows you to extract elements by name from a named list, i.e. take only values from a specific column in a given dataframe. 

In addition to the mean, it is also possible to calculate other statistics such as the median value and the range of values (for a numeric column)

```{r,  eval=FALSE,echo=TRUE}
mean(df$column)
median(df$column)
range(df$column)
```


## Exercise 1:

- Read in the Borders.csv data and check the frequency on column 'Sex'. 

- Using the same dataset, what are the mean and median values for LengthOfStay?

## Data Exploration - Crosstabs

The table() function can also be used to create crosstabs from your data. Using the following code will give a crosstab for column1 and column2:

```{r,  eval=FALSE,echo=TRUE}
table(df$column1, df$column2)
```

Using our data:

```{r,  eval=FALSE,echo=TRUE}
table(Borders$HospitalCode, Borders$Sex)

addmargins(table(Borders$HospitalCode, Borders$Sex))
```


## Data Manipulation 


A very common way of manipulating data in R is by using the `dplyr` package. This package exists as part of a group of R packages known as the "tidyverse". The tidyverse is comprised of multiple packages, with each package designed to do their respective task very efficiently. 



```{r,  eval=FALSE,echo=TRUE}
install.packages("dplyr")

library(dplyr)
```




## Comparison Operators

It is possible to selects rows (using the function filter) in a dataframe, the table below shows a selection of comparison operators that can be used. 




```{r,  echo=FALSE}
    kable(table_contents,
          col.names = c("Operator", "Function"),
          format = "markdown")
```


## Logical Operators

In addition to comparison operators, sometimes it is necessary to use logical operators. The table below  



```{r,  echo=FALSE}   
kable(table_contents2,
          col.names = c("Operator","Text Equivalent", "Definition"),
          format = "markdown")
```

## Let's try using the operators 

Using the Borders data, get all records with Specialty E12. We can use the filter() function to use only specific rows from the data frame. This works in a similar way to 'select if' in SPSS.

```{r,  eval=FALSE,echo=TRUE}
Borders_E12 <- filter(Borders, Specialty == "E12")
```

Use filter() with the Borders data to get patients who attended hospital B120H and had a length of stay greater than 10.  


```{r,  eval=FALSE,echo=TRUE}
Borders_filtered <- filter(Borders, 
                           HospitalCode == "B120H" & 
                           LengthOfStay > 10)

```



## Exercise 2:

- How many patients had a length of stay between 2 and 6 days inclusive in Borders General Hospital (B120H)?


## mutate()

Often there is a need to create a new column in a dataframe or modify an existing column The simplest way to do this is to use the mutate() function. 


```{r,  eval=FALSE,echo=TRUE}
mutate(df, newcolumn = expression)
```

For example if we want to create LOS divided by 2. 


```{r,  eval=FALSE,echo=TRUE}
Borders_2 <- mutate(Borders, LOS2 = LengthOfStay/2)
```





## Pipe Operator 

While all the dplyr functions shown are useful on their own, there are times when we need to use more of them to achieve desired outputs. For this, dplyr contains the pipe operator, %>%. This operator works by linking the dplyr function together. 

The pipe operator essentially means "and then". This makes reading your code much easier, as rather than having forcing several functions into one line of code, the pipe allows you to refer to your data frame and then perform several functions on it. 

A common shortcut for the pipe operator is Ctrl + Shift + M

## Pipe Operator 

For example, if we wanted to get all records with HospitalCode "B102H" and sort by Dateofbirth we would have had to run this code:

```{r,  eval=FALSE,echo=TRUE}
arrange(filter(Borders, HospitalCode == "B102H"), Dateofbirth)
```

However, we can make this code much easier to read by introducing the pipe operator:

```{r,  eval=FALSE,echo=TRUE}
Borders %>%
  filter(HospitalCode == "B102H") %>%
  arrange(Dateofbirth)
```

Note: There is no longer a need for dataframe as the first argument in each function as R knows you are referring to the Borders data frame

## arrange()

Data can also be sorted with dplyr using the arrange() function. Multiple columns can be selected and arrange() will sort the dataframe in the order the columns are selected. 
  

```{r,  eval=FALSE,echo=TRUE}
arrange(df, column1, column2, desc(column3))
```

Using our data we can sort using the Hospital Code in ascending order:


```{r,  eval=FALSE,echo=TRUE}
arrange(Borders, HospitalCode)
```

## select()

Sometimes you will only be interested in a few columns in your dataframe. The select() function allows you to specify certain columns from within your dataframe to select out. 


```{r,  eval=FALSE,echo=TRUE}
select(df, column_name)
```

Select() can also be used to delete a specific column, you can simply run the following code:

```{r,  eval=FALSE,echo=TRUE}
select(df, -column_name)
```

Lets try using the Borders data. 

```{r,  eval=FALSE,echo=TRUE}
select(Borders, -Postcode)
```

## Example 

Select the URI, Specialty and LengthOfStay columns, filter for rows which contain C8 for Specialty and arrange by LengthOfStay.


```{r,  eval=FALSE,echo=TRUE}
Borders %>%
  select(URI, Specialty, LengthOfStay) %>%
  filter(Specialty == "C8") %>%
  arrange(LengthOfStay)
```


## group_by() 

The group_by() function allows you to easily aggregate your data into groups. This function simply list the desired columns you wish to group by within your dataframe. 


```{r,  eval=FALSE,echo=TRUE}
group_by(df, column_name)
```
Using our data:


```{r,  eval=FALSE,echo=TRUE}
group_by(Borders, HospitalCode)
```

As you can see, using the group_by function on its own doesn't affect the appearance of the data. However, the output in the console now shows the number of groups within the data 

```{r,  eval=FALSE,echo=TRUE}
Groups: HospitalCode [48]
```


## summarise()  

The summarise() function allows you to calculate summary statistics for each desired group. To use this function we trying an example using the Borders data, using the code below we calculate the mean length of stay for each hospital. 

```{r,  eval=FALSE,echo=TRUE}
Borders %>%
  group_by(HospitalCode) %>%
  summarise(mean_LOS = mean(LengthOfStay)) %>%
  ungroup()
```

If we run this code without group_by, then the output will be the mean length of stay across all the data.

```{r,  eval=FALSE,echo=TRUE}
Borders %>%
  summarise(mean_LOS = mean(LengthOfStay))
```


## count()

The count() function is very useful for running frequencies on a dataframe. This function automatically calls group_by() and produces counts for a specified column.

```{r,  eval=FALSE,echo=TRUE}
Borders %>%
  count(Sex)
```

You can also sort frequencies in descending order using count()

```{r,  eval=FALSE,echo=TRUE}
Borders %>%
  count(Specialty, sort = TRUE)
```

## rename() 

The dplyr package also makes it very straight forward to rename specific columns by using the rename() function respectively. The rename() function works as follows: 

```{r, eval=FALSE,echo=TRUE}
df <- rename(df, new_name = existing_name)
```

```{r, eval=FALSE,echo=TRUE}
Borders <- rename(Borders, DateOfBirth = Dateofbirth)
```

If you look at your Borders dataframe, you will see that the Dateofbirth column is now called DateOfBirth. 

## recode() 

While rename() changes the column name, recode() changes the values within the column. The recode() function works best when used within a mutate(): 

```{r,  eval=FALSE,echo=TRUE}
df <- df %>% 
  mutate(column_name = recode(column_name, 
                              "existing_code" = "new_code"))
```

```{r,  eval=FALSE,echo=TRUE}
Borders <- Borders %>% 
  mutate(HospitalCode = recode(HospitalCode, "B120V" = "B120H"))
```


## Exercise 3

- Select the URI, Specialty. and DateOfBirth columns from Borders data. Arrange the data in ascending order by Specialty. Use the filter function to count how many records have a missing Dateofbirth value.

## Joining Data 

The dplyr package also makes it very easy to merge data by matching files together using common variables. There are several join functions within dplyr that are designed to merge dataframes together to create one dataframe containing the relevant variables.

The general structure of a join function is to specify the two dataframes used for merging, x and y, and a common variable to match by. For example, for a left_join you would have: 

```{r,  eval=FALSE,echo=TRUE}
left_join(x = dataframe1, y = dataframe2, by = "common_variable")
```

## Examples of Merges

![dplyr joining functions](images/dplyr_joins.PNG){ width=100%, height=100%}

## Example 
  
  Read in Baby5.csv and Baby6.csv
  
```{r,  eval=FALSE,echo=TRUE}
  
baby5 <- read_csv("Baby5.csv")
baby6 <- read_csv("Baby6.csv")
baby_joined <- baby5 %>%
  left_join(baby6, by = c("FAMILYID", "DOB"))

```
  


## Data Visulisation 

A basic line graph can be created using the following code:

```{r,  eval=FALSE,echo=TRUE}
x <- c(1, 3, 2, 4)
# Plot the data
plot(x, type = "l")
```

 Note that type = "l" simply means to plot a line plot(x, type="l")


```{r, echo=FALSE}
x <- c(1, 3, 2, 4)
par(mar = c(10, 4, 4, 2))
plot(x, type = "l")
```


## Example 


- Read in the Borders (inc Age) data

```{r,  eval=FALSE,echo=TRUE}
Borders_age <- read.csv("Borders (inc Age).csv")
```

- Calculate frequencies of admissionday

```{r,  eval=FALSE,echo=TRUE}
counts <- table(Borders_age$admissionday)
barplot(counts)
```



## Customising Plots 

It is possible to customise plots created in R. 


- Change the colour and width of the bars


```{r,  eval=FALSE,echo=TRUE}
barplot(counts,
  xlab = "Admission Day", ylab = "Number of Admissions",
  main = "Distribution of Admission Day", col = "blue", space = 1
)
```


## Exercise 4

- Filter your data to select records with HospitalCode "B109H". Create a histogram for patient's length of stay. Add a title and axis labels and save the plot to your H:/ drive as a PNG. Hint: Use hist() to create the histogram



## Resources 


[PHI Intro to R in NSS](https://github.com/Health-SocialCare-Scotland/R-Resources/blob/master/Intro to R-NSS.md)

[R Guidance for PHI](https://health-socialcare-scotland.github.io/R-Resources/R_Guidance_for_PHI.html)

[https://dplyr.tidyverse.org/ ](https://dplyr.tidyverse.org/)

[R for Data Science Book ](http://r4ds.had.co.nz/)

[NSS R Resources Dashboard](https://scotland.shinyapps.io/nhs-r-resources/)

[Using R with SMRA](https://www.isdscotland.org/About-ISD/Methodologies/_docs/Using-R-with-SMRA-V1-1.pdf)


## Contact 


If you have questions or need help, you can contact

PHI R User Group Inbox: <nss.Rusergroupinbox@nhs.net> (email here to be added to the distribution list)

PHI R User Group Distribution List: <nss.rusergp@nhs.net>



# Thank You
